
" Add the Syntastic-specific pieces of the status line.
"
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

let g:syntastic_mode_map = {
\ 'mode':               'active',
\ 'passive_filetypes':  ['typescript'],
\ }

let g:syntastic_always_populate_loc_list  = 1
let g:syntastic_auto_loc_list             = 1
let g:syntastic_check_on_open             = 1
let g:syntastic_check_on_wq               = 0

" Syntastic TypeScript
"
"let g:syntastic_typescript_tsc_fname = ''

" Tsuquyomi TypeScript + Syntastic
"
let g:tsuquyomi_disable_quickfix = 1
let g:syntastic_typescript_checkers = ['tsuquyomi'] " instead of 'tsc'

" Syntastic Angular HTML

" let g:syntastic_html_tidy_blocklevel_tags = ['myCustomTag']
" let g:syntastic_html_tidy_inline_tags = []

" 's:qmr' stands for 'list of HTML Tidy quiet message regexes';
" I just didn't want to repeat a long variable name several
" times. We're going to build it with several calls to add()
" and extend(), so each block of regexes can be documented.
"
let s:qmr = []

" Allow (what HTML Tidy thinks are) invalid attribute names.
" Explicitly allow [prop], (event), and [(bananasInABox)],
" along with #refs (template reference variables) and
" *ngIf / *ngFor / etc. structural directives.
"
" Essentially, this pattern matches messages like...
"
"   attribute name "FOO" (value="...") is invalid
"
" ...but tries to narrow FOO down to only the error messages
" that are generated by a valid Angular template, so any
" other messages make it through.
"
call extend(s:qmr, [
\ 'attribute name "\('
\ . '\|' . '\[\w\+\]'
\ . '\|' . '(\w\+)'
\ . '\|' . '\[(\w\+)\]'
\ . '\|' . '#\w\+'
\ . '\|' . '\*ng\(for\|if\|switch\(when\|default\)\)'
\ . '\)" (value=".\+") is invalid',
\ ])

" Allow all unrecognized element and attribute names.
"
" I'd prefer to be much more surgical about this, but that
" would require calling Angular's own template parser, and I
" haven't gotten that far just yet. Not even sure it's
" possible yet.
"
" When it *is* possible, explicitly allow attribute names
" that start with these prefixes:
"
"   '\(bind\|bindon\|let\|on\|ref\|\)-'
"
call extend(s:qmr, [
\ '> proprietary attribute "',
\ '> is not recognized!',
\ 'discarding unexpected <',
\ ])

" Allow empty elements, since they might be bound with, for
" example, [textContent] or [innerHtml].
"
call add(s:qmr, 'trimming empty <')

" Allow #whatever attributes without values.
"
call add(s:qmr, '> attribute "#\w\+" lacks value')

" Allow ngSwitchDefault without a value.
"
" TODO: Add any others that make sense here.
"
call add(s:qmr, 'attribute "\*ngswitchdefault" lacks value')

" Allow input, select, etc., without an explicit form element.
"
call extend(s:qmr, [
\ 'inserting implicit <form>',
\ 'missing </form> before <',
\ "<input> isn't allowed in <body> elements",
\ ])

" Allow images without alt or src attributes, since the
" values for alt and src might be specified programmatically.
"
call add(s:qmr, '<img> lacks "\(alt\|src\)" attribute')

" Prepend all regexes with the 'magic' and 'case insensitive'
" markers.
"
call map(s:qmr, ' ''\m\c'' . v:val ')

let g:syntastic_html_tidy_quiet_messages = { 'regex': s:qmr }

